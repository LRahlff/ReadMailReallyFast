/*
 * tcp_client.cpp
 *
 *  Created on: 03.01.2021
 *      Author: doralitze
 */

#include "net/tcp_client.hpp"

#include <ev++.h>
#include <fcntl.h>
#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <utility>
#include <list>

#include "net/netio_exception.hpp"
#include "net/socketaddress.hpp"
#include "net/sock_address_factory.hpp"

namespace rmrf::net {

tcp_client::tcp_client(
    const destructor_cb_type destructor_cb_,
    auto_fd&& socket_fd_,
    const socketaddr& own_address_,
    const socketaddr& peer_address_
) :
    connection_client{std::forward<auto_fd>(socket_fd_), peer_address_, destructor_cb_}
{
    // TODO query own socket name (in the future this will be the only construcor, as we are generated by the client_factory, io is initialized in connection_client and we query the appropiate own endpoint here)
    // TODO log created client
    this->own_address = own_address_;
}

/*
// TODO move to client_factory
auto_fd tcp_client::get_connection(const std::string& peer_address_, const std::string& service_or_port, int ip_addr_family) {
    std::list<socketaddr> connection_candidates = get_socketaddr_list(peer_address_, service_or_port, socket_t::TCP);

    if (ip_addr_family == AF_UNSPEC) {
        ip_addr_family = connection_candidates.front().family();
    }

    if (!(ip_addr_family == AF_INET || ip_addr_family == AF_INET6)) {
        throw netio_exception("Invalid IP address family.");
    }

    // TODO build another nice HL structure wrapper for outbound connections
    int status = 1;

    do {
        if (connection_candidates.empty()) {
            throw netio_exception("Unable to find suitable connection candidate.");
        }

        socketaddr socket_identifier = connection_candidates.front();
        connection_candidates.pop_front();
        auto_fd socket_candidate{socket(socket_identifier.family(), SOCK_STREAM, 0)};

        if (socket_candidate.valid()) {
            if (connect(socket_candidate.get(), socket_identifier.ptr(), socket_identifier.size()) == 0) {
                status = 0;

                if (
                    const auto existing_fd_flags = fcntl(socket_candidate.get(), F_GETFL, 0);
                    existing_fd_flags == -1 || fcntl(socket_candidate.get(), F_SETFL, existing_fd_flags | O_NONBLOCK) == -1
                ) {
                    throw netio_exception("Failed to set socket mode. fcntl resulted in error:" + std::to_string(errno));
                }

                // Hier bin ich mir nicht sicher, wie ich das am besten mache. Auch mit socketaddr und type cast ist das irgendwie doof.
                // Das Problem besteht darin, dass erst nach erfolgreichem connect der Port auf dieser Seite bekannt ist.
                socketaddr sa_local;
                socklen_t sa_local_len = sizeof(sockaddr_storage);

                if (getsockname(socket_candidate.get(), sa_local.ptr(), &sa_local_len)) {
                    // Update length field after the internal structure was modified
                    // TODO: Maybe make this an internal method in socketaddr to update the size
                    sa_local = sa_local.ptr();
                    this->own_address = sa_local;
                }
                
                // Store remote connection endpoint (that is prior to redirect)
                this->peer_address = socket_identifier;
                return std::forward<auto_fd>(socket_candidate);
            }
        }

        // We don't need to worry about closing broken fd as auto_fd handles this for us
    } while (status == 1);
    return null_fd{};
}

// TODO remove and replace with raw socketaddr constructor from factory and implement connect construcor
tcp_client::tcp_client(
    const std::string& peer_address_,
    const std::string& service_or_port,
    int ip_addr_family
) :
    connection_client{get_connection(peer_address_, service_or_port, ip_addr_family), this->get_peer_address()},
    destructor_cb(nullptr)
{}

tcp_client::tcp_client(
    const std::string &peer_address_,
    const std::string &service_or_port
) :
    tcp_client(peer_address_, service_or_port, AF_UNSPEC)
{}

tcp_client::tcp_client(
    const std::string &peer_address_,
    const uint16_t port_
) :
    tcp_client(peer_address_, std::to_string(port_))
{}*/

tcp_client::~tcp_client() {}

ssize_t tcp_client::push_write_queue(::ev::io& w, iorecord& buffer) {
    return write(w.fd, buffer.ptr(), buffer.size());
}

inline uint16_t tcp_client::get_port() {
    const auto optional_port = this->peer_address.get_port_if_applicable();
    if (!optional_port)
        throw netio_exception("The associated peer (if any) does not seam to support the concept of a port.");
    return optional_port.value();
}

void tcp_client::read_from_socket(::ev::io& w) {
    // notify incomming_data_cb
    uint8_t buffer[1024];

    ssize_t n_read_bytes = recv(w.fd, buffer, sizeof(buffer), 0);

    if (n_read_bytes < 0) {
        throw netio_exception("Failed to read from network socket in TCP client.");
    }

    if (n_read_bytes == 0) {
        // TODO find a way to properly announce the closed connection
        this->stop_server();
        return;
    } else {
        this->in_data_cb(iorecord(buffer, n_read_bytes));
    }
}

}
